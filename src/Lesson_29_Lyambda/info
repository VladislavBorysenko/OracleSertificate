Самый короткий вариант записи лямбда вырожения:
stud->stud.avgGrade>8.5
более полный варинант написания лямбда выражения выглядит вот так:
(Student stud)->{return stud.avgGrade>8;}
в Лямбда выражениях оператор стрелка разделяет параметры метода и тело метода

В лямбда выражении справа от оператора стрелка находится тело метода, которое было у метода соответствующего класса,
имплементировавшего наш интерфейс с единственным методом

Вы можете использовать смешанный вариант написания лямбда выражения:
слева от оператора стрелка писать короткий вариант, справа - полный или наоборот

Если вы используетеполный вариант написания для части лямбда выражения справа от стрелки, то вы должны использоать слово
- return и знак ";"

Левая часть лямбда выражения может быть написанна в краткой форме, если метод интерфейса принимает только 1 параметр.
Даже если метод интерфейса принимает 1 параметр, но в лямбда выражении вы хотите писать данный параметр используя его тип данных,
тогда вы уже должны писать левую чать лямбда выражения в скобках

Если в правой части лямбда выражения вы пишете больше одно statement-a, то вы должны использоватьего полный вариант написания

пример:
def( ()->5 );
def( (x)->x.length() );
def( (String x)->x.length() );
def( (y,x)->x.length() );
def( (String y,String x)->x.length() );

Compile time errors:
def( x->{x.length();});
def( x->{return x.length() });
def( x,y->x.length() );

method( (int x, int y)->{int x=5; return10;} );     NOT OK!
method( (int x, int y)->{ x=5; return10;} );        OK!
method( (int x, int y)->{ int x2=5; return10;} );        OK!

_________________interface Predicate<T>________________________________________________________________________________
Лямбда вражения работают с интерфейсом, в которм есть только 1 метод.
Такие интерфейсы называются функциональными интерфейсами, т.е.
интерфейсами, пригодными для функционального программирования

public interface Predicate<T>{
boolean test(T t);
}

Интерфейс Predicate находиться в java.util.functional

Метод класса ArrayList removeIf использует Predicate<T>.

functional interfaces - могут содержать толко один обстрактній метод

______________interface Consumer & Supplier_______________________________________________________________
consumer - потребитель
suplier - поставщик